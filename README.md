# 设计模式指引

## 创建型模式

作为实现者，我需要创建对象。作为用户，我需要获得对象。那么就考虑创建型模式。可供选择的模式有5种。

1. 单例模式。如果创建出来的对象具有无论使用者获得多少次，获得的对象都是同一个的，就要考虑使用单例模式。
2. 原型模式。如果创建的对象不是同一个，且创建对象需要消耗很长时间，要考虑性能问题，那么考虑使用原型模式。
3. 工厂模式。如果以后需要生成不同的对象，需要考虑统一的方法来提供不用类型的对象创建的方法名称，那么考虑工厂模式。
4. 抽象工厂模式。如果连提供对象的对象都要一个对象来提供，那么采用抽象工厂模式。
5. 创建者模式。如果提供对象的对象需要调用另外一个对象的一系列方法来创造对象的，使用创建者模式。

## 结构型模式

1. 代理模式。如果需要一个虚拟中介来替代直接对远程对象的操作，那么使用代理模式。
2. 适配器模式。如果对象功能相同，接口不同，那么可以考虑使用适配器模式。
3. 桥接模式。需要的对象由几个不同的维度组成。
4. 过滤器模式。以不同的规则过滤对象，并且规则可能需要支持组合，使用过滤器模式。
5. 组合模式。在一个树状的对象节点中，节点和末端对象都具备相同的方法，可以透明地使用，采用组合模式。
6. 装饰器模式。一个对象上可以灵活地增加不同的功能。
7. 外观模式。提供了客户端请求的简化方法和对现有系统类方法的委托调用。
8. 享元模式。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

## 行为型模式

1. 责任链模式。对象里面链状引用，对第一个调用方法。
2. 命令模式。是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 
3. 解释器模式。语法树。
4. 迭代器模式。它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 
5. 中介者模式。中介者模式建议你停止组件之间的直接交流并使其相互独立。这些组件必须调用特殊的中介者对象，通过中介者对象重定向调用行为，以间接的方式进行合作。最终，组件仅依赖于一个中介者类，无需与多个其他组件相耦合。
6. 备忘录模式。在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
7. 观察者模式。观察者模式（有时又被称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）是软件设计模式的一种。
8. 状态模式。类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
9. 空对象模式。当为空或者不存在的时候返回一个空对象，避免程序NullPointException异常发生。
10. 策略模式。一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。
11. 模板模式。一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。
12. 访问者模式。我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

