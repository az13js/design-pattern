# 设计模式指引

## 创建型模式

作为实现者，我需要创建对象。作为用户，我需要获得对象。那么就考虑创建型模式。可供选择的模式有5种。

1. 单例模式。如果创建出来的对象具有无论使用者获得多少次，获得的对象都是同一个的，就要考虑使用单例模式。
2. 原型模式。如果创建的对象不是同一个，且创建对象需要消耗很长时间，要考虑性能问题，那么考虑使用原型模式。
3. 工厂模式。如果以后需要生成不同的对象，需要考虑统一的方法来提供不用类型的对象创建的方法名称，那么考虑工厂模式。
4. 抽象工厂模式。如果连提供对象的对象都要一个对象来提供，那么采用抽象工厂模式。
5. 创建者模式。如果提供对象的对象需要调用另外一个对象的一系列方法来创造对象的，使用创建者模式。

## 结构型模式

1. 代理模式。如果需要一个虚拟中介来替代直接对远程对象的操作，那么使用代理模式。
2. 适配器模式。如果对象功能相同，接口不同，那么可以考虑使用适配器模式。
3. 桥接模式。需要的对象由几个不同的维度组成。
4. 过滤器模式。以不同的规则过滤对象，并且规则可能需要支持组合，使用过滤器模式。
5. 组合模式。在一个树状的对象节点中，节点和末端对象都具备相同的方法，可以透明地使用，采用组合模式。
6. 装饰器模式。一个对象上可以灵活地增加不同的功能。
7. 外观模式。提供了客户端请求的简化方法和对现有系统类方法的委托调用。
8. 享元模式。在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

## 行为型模式

1. 责任链模式。对象里面链状引用，对第一个调用方法。
2. 命令模式。是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 
3. 解释器模式。语法树。
4. 迭代器模式。它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 
5. 中介者模式。中介者模式建议你停止组件之间的直接交流并使其相互独立。这些组件必须调用特殊的中介者对象，通过中介者对象重定向调用行为，以间接的方式进行合作。最终，组件仅依赖于一个中介者类，无需与多个其他组件相耦合。
6. 备忘录模式。在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
7. 观察者模式。当一个对象在运行时发生变化，需要让其它相关对象也知道这个变化，此时可以使用观察者模式。这种模式通过接口定义限制了观察者和被观察者之间绑定和通知调用的方法，从而实现两者的关系绑定和通知机制的规范化。在使用时，观察者和被观察者之间除了必须实现的模式定义的接口之外，不应该有太多的耦合。这种模式的缺点是，如果对象的通知方式不是一对多，而是多对多或者循环通知的话，有可能造成死循环。这种模式的一种应用场合是，被观察对象内部逻辑比较复杂，改造成本较高，而观察者有多个、改造成本较低且可能还会添加新的观察者时，通过在被观察对象上实现相关的接口或方法，可以在较少的改动下让被观察对象内部的变化通知到观察者。
8. 状态模式。类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。
9. 空对象模式。如果程序的主要逻辑是通过某些方法获得一个（或者一些）对象并对这些对象进行一系列操作，而我们不希望由于某些原因无法提供对象，导致主要逻辑无法执行时，可以通过给出一个具备正常的方法但是不会引起任何副作用的“空对象”给主要逻辑进行调用，从而让程序执行下去。当然，空对象可以实现一个方法让调用者得知这个对象是不是空对象。使用场合比如：主程序获得一个关于日志记录的对象然后操作这个对象，但是有时不能提供真正可用的日志记录对象，此时给出一个具备相同方法但是没有真正记录日志功能的空对象给程序操作，从而使程序能在不记录日志的情况下正常运作。这个设计模式显而易见的好处是不需要主程序修改任何逻辑。
10. 策略模式。当你发现一个功能有不同的实现方式，这些实现方式之间随意替换不会引起它们被利用的方法发生改变，这时可以使用策略模式。一种实现方式就是一种策略，例如不同的排序算法就好比不同的策略，它们功能一样的——用于排序，只是不同排序算法执行时间、内存占用不同，可以根据情况选择合适的算法。策略模式的好处是，策略被替换后主程序对策略的使用逻辑不变。因此这种模式可以用在主程序逻辑因为种种原因需要保持不变，而具体的策略（也就是主程序调用的子过程）需要被添加、修改或者替换的场合。另外，一个过程中间的某些步骤存在较为复杂的条件分支时，可以把这个过程拆分成不同的策略，这样可以降低逻辑的复杂度。
11. 模板模式。一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。
12. 访问者模式。我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。

- [C语言中文网](http://c.biancheng.net/view/1378.html)
- [菜鸟教程](https://www.runoob.com/design-pattern/observer-pattern.html)
- [W3Cschool](https://www.w3cschool.cn/shejimoshi/null-object-pattern.html)

